\section{Data Repository}
% How is the data repository modelled.
When thinking of a what a data repository is, words like ``tuple spaces'', ``data bases'' or even ``comma separated files'' might spring to mind. However to utilise LTL formulae to specify properties about the data in the repository and verify if the properties are satisfied, it is necessary to carefully consider what data repository abstraction to use. 

% Paragraph:
% - Make the connection to transition systems
In the literature (Baier and Katoen, 2008)\cite{baier2008principles} use a Transition System (TS) without terminal states as a reactive system, for which they are checking LTL formulae against. Where they use the following definition of a TS:
\begin{definition}[Transitions System (TS)\cite{baier2008principles}]\label{def:ts}
A \emph{transition system} $TS$ is a tuple $\left(S, Act, \longrightarrow, I, AP, L \right)$, where
\begin{itemize}
  \item $S$ is a set of data states
  \item $Act$ is a set of actions
  \item $\longrightarrow \subseteq S \times Act \times S$ is a transition relation
  \item $I \subseteq S$ is a set of initial states
  \item $AP$ is a set of atomic propositions
  \item $L : S \rightarrow 2^{AP}$ is a labelling function
\end{itemize}
\end{definition}
Some of the key elements of a TS are that it contains states and transitions between the states, furthermore that transitions are labelled with an action. 

% Paragraph:
% - States == Data resources
% - Transition == Dependency
To model a data repository as a TS, one could consider data resources or data points from the data repository as states in the TS and dependencies between data resources would be the transitions between states. A dependency between two data resources can be seen as if a data resource $r_1$ was created by using information from another data resource $r_2$ or is dependant $r_2$ in another way, then a dependency exists from $r_1$ to $r_2$. For instance in a data repository of scientific papers, i.e. each paper is a data resources, would this paper have a dependency to each of the papers it references, as the information from those references were used when composing this paper. It could also be that a dependency existed to a resource that defines rules about the format of the paper. This is what is referred to as a policy and will be introduced in a later section.
\begin{definition}[Dependency Between Data Resources]
Let $r_i$ and $r_j$ be data resources in the same data repository $DR$, and let $r_i$ be derived fully or partially from $r_j$, i.e. information from $r_j$ was used when creating $r_i$. Then there exists a dependency from $r_i$ to $r_j$.
\end{definition}
Modelling dependencies in this way inherently describes the past and if you were to follow the dependencies from a data resource they would paint a picture of how that resource got to be.

% Paragraph: 
% - No terminal states
As mentioned (Baier and Katoen, 2008) uses a TS without any terminal states to ensure that all paths and traces in the TS are infinite. The reason being that it simplifies the model-checking algorithm. However it is possible to define the semantics of LTL for finite paths~\cite{baier2008principles}. To achieve infinite paths and thereby traces in the data repository modelled as a TS, all data resources without any dependencies to other data resources have a dependency to itself, a so called \emph{self-dependency}. A self-dependency implies that the data resource was created independently from any other data resource. By introducing self-dependencies ensure that no terminal state can ever be reached or will even exists in the data repository and as a result all paths in the data repository are infinite.

% Paragraph:
% - Actions
In a TS transitions can have an action as a label, which describes what action was taken in order to make that transition from one state to another in the TS. As suggested placing some data resource in the data repository can gives rise to dependencies between resources and thus every dependency is a result of the same action. Therefore adding the same action as label to every dependency is considered redundant and they can be left empty. In other words dependencies between data resources merely specifies the relationship between them.

% Paragraph: 
% - AP
% - Labelling function
The set of atomic propositions and labelling function for a TS can be considered the same for a data repository. The labelling function will relate a set of atomic propositions to any data resource in the data repository, where the set only contains the atomic propositions that are satisfied by the data resource. More intuitively the labelling function describes the values of the data resource.

% Paragraph: 
% - Initial states
According to Definition~\ref{def:ts} should the initial states of a TS be explicitly defined. However it is not desirable, that the data repository itself should restrict, which data resources can and can not be read. Therefore should the every data resource be considered as an initial state.

% Summarise the definition of a data repository
Given all of the above descriptions of how the parts of a TS could be modelled in a data repository, it is possible to define a data repository as follows:
\begin{definition}[Data Repository (DR)]
A \emph{data repository} $DR$ is a tuple $\left(R, \longrightarrow', A, L, M \right)$, where
\begin{itemize}
  \item $R$ is a set of data resources
  \item $\longrightarrow \subseteq R \times R$ is a dependency relation
  \item $A$ is a set of attribute names
  \item $L$ is a set of literals
  \item $M : R \times A \rightarrow L$ is a mapping between data resources and attributes to literals
\end{itemize}
\end{definition}

\begin{example}[Data repository]\label{ex:data-repo}
Let us consider how a data repository of five data resources could look like. \autoref{fig:data-repo} shows how the five data resources could depend on each other. $r_5$ has dependencies to $r_3$ and $r_4$, $r_3$ has a dependency to $r_1$ and $r_4$ has a dependency to $r_2$. $r_1$ and $r_2$ was created completely independently and thus have no dependency to other resources, thus they have a \emph{self-dependency}.
\begin{figure}[!ht] 
    \begin{center}
        \input{figs/data-repository-example.tex}
        \caption{Sample data repository containing five data resources, their dependencies and atomic propositions.}
        \label{fig:data-repo}
    \end{center}
\end{figure}
The set of atomic propositions is defined as $AP = \left\{ a_1, a_2, a_3, a_4, a_4 \right\}$ and from \autoref{fig:data-repo} it can be seen what data resource has been labelled with what atomic propositions. That is $L(r_3) = \left\{ a_1, a_3 \right\}$.
\end{example}

% Insert Transition System stuff here

\begin{lemma}[Transformation from DR to TS]\label{lemma:dr-to-ts}
Let $DR=\left(R, \longrightarrow', A, L, M \right)$ and $TS=\left(S, Act, \longrightarrow, I, AP, L \right)$, then $DR$ can be transformed into a $TS$ with respect to a data resource $r \in R$ and a policy formula $\pf$. Let this transformation be denoted $DR \xrightarrow{r,\pf} TS$. We start by transforming $\pf$ into a corresponding LTL $\phi$ following \autoref{lemma:pf-to-ltl}, thus $\pf \xrightarrow{} \left(\phi, \tau\right)$ where $\phi$ over $AP_\phi$. The transformation of DR is then as follows:
\begin{itemize}
  \item $S = R$
  \item $Act = \varnothing$
  \item $\longrightarrow = \longrightarrow'$
  \item $I = \{r\}$
  \item $AP = AP_\phi$
\end{itemize}
Lastly the labelling function $L: R \rightarrow 2^{AP}$ is defined by the following. Given a resource $r$ then for each $ap \in AP$:
\begin{itemize}
    \item If $M(r, ap)$ is a boolean literal $b$ and $b = true$, then $ap \in L(r)$
    \item If $r \models \tau(ap)$, then $ap \in L(r)$
    \item Otherwise $ap \not\in L(r)$
\end{itemize}
\end{lemma}

% Definition of labelling function:
% Traverse every m of M:

\input{sections/grammar.tex}
\input{sections/policies.tex}

\subsection{Operations}
In the following will the allowed operations on the data repository be introduced
% Content:
% - User has to be defined in context before any operations can be performed
\subsubsection{Context}
Before considering the operations that can be performed on the data repository, it is necessary to consider the context in which the operations operate. The context is not part of the operations as such but having it configured properly is a prerequisite for performing the operations. The main purpose of the context is to populate values that can be used in resolving LTL formulae following the grammar introduced in \autoref{sec:grammar}. The primary value of concern is that a user is set, i.e. the name of the user/person performing the operations. The implementation abstracts away from authenticating the user, i.e. ensuring that the user is who it claims to be. However it should be trivial to see that an authentication system could be placed as a layer on top of the data repository.

In theory there is no limit to what the context could be extended with, e.g. the system that the operation is performed from, the name of the system etc.

% Content:
% - Author is automatically added as an attribute to the state
% Flow of PUT operation:
% - Check if user is set
% - Check if resource already exists
% - Add author attribute to the resource
% - Replace user predicate
% - Replace self reference
% - Concatenate policies
% - Check that policies are satisfied
% \item if $put(r, \conf, D)$ then $I' = \{ r \}$
\subsubsection{Put}\label{sec:put}
A data repository $DR=\left(R, \longrightarrow, I, AP, L \right)$ is initially empty but can be populated with data resources by utilising the \emph{put} operation. The put operation works directly on the data repository and does not as such needs a reference for it.
\begin{definition}[Put operation]
A operation $put(r, \conf, D)$ where
\begin{itemize}
  \item $r$ is a data resource
  \item $\conf$ is a confidentiality policy
  \item $D$ is a set of dependencies of $r$
\end{itemize}
\end{definition}
To consider a put operation successful means that the data resource $r$ is added to the set of data resources $R$ of $DR$. A prerequisite for carrying out a put operation is that the user is set in the context, furthermore that $r$ does not already exists in $R$. Next is a new attribute automatically generated for the data resource $r$. The new attribute is \emph{author} and its value is set to the user that is defined in the context, i.e. the author of the data resource is the user who performs the put operation. This ensures that every data resource in the repository has an author and it was shown in \autoref{ex:conf-reader-author} how it could be used. Now the confidentiality policy $\conf$ needs to be considered. Should it contain any \emph{self} predicates they need to be replaced with an internal unique reference to the data resource itself. The only thing left to handle before the data resource can be added to the data repository is to verify that the confidentiality policy is satisfied. More formally with the confidentiality policy $$\phi = \conf \land \bigwedge\limits_{d \in D} \conf_d$$ and a data repository copy $DR' = \left(R', \longrightarrow', I', AP', L' \right)$ of the data repository $DR$ where $R' = R \cup r$ and $I' = \left\{ r \right\}$:
\begin{itemize}
    \item if $DR' \models \phi$, then $R = R'$
    \item if $DR' \not\models \phi$, then $R = R$
\end{itemize}
More informally it should be checked that the confidentiality policy $\conf$ of the data resource $r$ and all the inherited confidentiality policies from the dependencies of $r$ holds under the data repository $DR$. That is with the assumption that $r$ is added to the set of resources and $r$ is considered an initial state. If the confidentiality polices hold under the data repository the data resource is added to the set of resources and the operation can be considered complete.

% Explain why confidentiality is checked here
The main reason why confidentiality policies are checked for satisfiability once they are being placed in the data repository, is to avoid that a user can not query the data resource that it just put and to avoid having data resources in the repository that is infeasible to query. Let us consider the two cases more specifically with some examples.

\begin{example}[Unable to query self-placed resource]
Consider that the user \emph{John} had placed a data resource $r$ in a data repository $DR$ with the corresponding confidentiality policy $\conf = reader() == user("Jane")$. Even though John made the data resource himself, he will never be able to satisfy $\conf$ when querying for $r$, thus making it infeasible for him to read it again.
\end{example}

\begin{example}[Infeasible to query resource]
Consider a data repository $DR$ containing two data resources $r_1$ and $r_2$, where $r_2$ has a dependency to $r_1$ and thus inherit the confidentiality policy $\conf_1$ that is associated to $r_1$. Say $\conf_1 = \phi$ where $\phi$ is some policy formula and $r_2$ has the confidentiality policy $\conf_2 = \lnot \phi$ associated to it. When querying for $r_2$ will both $\conf_1$ and $\conf_2$ have to be satisfied, i.e. $\phi \land \lnot \phi$. The two policies clearly contradicts each other and can never be satisfied, thus making it infeasible to query $r_2$ and any data resources that has a dependency to $r_2$.
\end{example}

% Content:
% - Confidentiality polices are checked every time (not efficient)
% Flow of QUERY operation:
% - Check if user is set
% - Check if resource exists
% - Replace user predicate
% - Replace self reference
% - Check that integrity policies are satisfied
% - Check that confidentiality policies are satisfied
% \item if $query(r, \inte)$ then $I' = \{ r \}$
\subsubsection{Query}\label{sec:query}
Once data has been put in the data repository it might be interesting to query some of the resources again later on. To allow for this has the \emph{query} operation been introduced:
\begin{definition}[Query operation]
A operation $query(r, \inte)$ where
\begin{itemize}
  \item $r$ is a data resource
  \item $\inte$ is an integrity policy
\end{itemize}
\end{definition}
As with the put operation is an explicit reference for the data repository $DR$, not needed as it is performed directly on the data repository. For a query operation to be carried out successfully a few things needs to be resolved and satisfied. A query operation is considered successful if the the requested data resource is returned from the data repository. A prerequisite for carrying out a query operation is that the user is set in the context, just like for the put operation, and that the data resource does exists in the data repository. Now both the integrity and confidentiality policies need to be considered. For the integrity policy $\inte$ this means that if it contains any \emph{self} predicates they need to be replaced with the internal unique reference to the data resource $r$, i.e. the data resource that is attempted to be queried. Once that is complete is should be checked that:
\begin{align*}
    DR \models \inte \text{, where $r$ is considered as initial state}
\end{align*}
The only thing left to handle before the data resource $r$ can be returned to the user, is to check if the confidentiality policy $\conf$ of $r$ and the inherited confidentiality policies of $r$'s dependencies are satisfied under the data repository $DR$ where $r$ is considered as the initial state. More formally with the confidentiality policy $$\phi = \conf \land \bigwedge\limits_{d \in D} \conf_d$$:

\begin{itemize}
    \item if $DR' \models \conf$, then $r$ is returned
    \item if $DR' \not\models \conf$, then $\varnothing$ is returned
\end{itemize}

Regardless of if a query operation was carried out successfully or not, does not modify the data repository in any way. Thus a query operation will return the queried data resource but it will remain in the data repository. Consider the following example:

\begin{example}
Having a data repository $DR$ shown in \autoref{fig:query}
\begin{figure}[!ht]
    \begin{center}
        \input{figs/query-example.tex}
        \caption{Data repository $DR$ containing three data resources $r_1, r_2, r_3$.}
        \label{fig:query}
    \end{center}
\end{figure}
\end{example}